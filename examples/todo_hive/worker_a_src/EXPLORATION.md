# Worker A 探索記錄

本文檔記錄了 Worker A 在實現過程中考慮的各種方案和取捨。

## 認證存儲選項探索

### 方案 A1：內存用戶映射（In-memory User Map）

**特點：**
- 使用 Python 字典存儲用戶名和密碼對
- 實現簡單，無需文件操作
- 數據僅存在於內存中

**優點：**
- 實現最快
- 無需處理文件 I/O
- 適合快速原型和單元測試

**缺點：**
- ❌ 無持久化能力
- ❌ 服務器重啟後所有用戶數據丟失
- ❌ 不適合任何需要數據保留的場景
- ❌ 無法在多實例間共享狀態

**使用場景：**
- 僅用於臨時測試
- 不需要持久化的演示場景

### 方案 A2：檔案基礎用戶存儲（File-based User Storage）✅ 已選擇

**特點：**
- 使用 JSON 文件存儲用戶資料
- 每次操作讀寫文件
- 提供持久化能力

**優點：**
- ✅ 數據持久化，服務器重啟不丟失
- ✅ JSON 格式易於閱讀和調試
- ✅ 無需額外數據庫依賴
- ✅ 可以輕易遷移到數據庫（讀寫接口相同）
- ✅ 適合演示和單機部署

**缺點：**
- 併發寫入可能導致數據不一致（但對演示場景可接受）
- 性能不如數據庫（但對演示場景足夠）

**選擇理由：**
在演示場景下，持久化能力是必要的。方案 A2 提供了簡單且有效的持久化方案，同時保持了實現的簡單性。

**未探索的替代方案：**
- 關係型數據庫（SQLite、PostgreSQL）
  - 優點：事務支持、併發控制
  - 缺點：增加複雜度、需要數據庫依賴
  - 理由：超出了最小實現範圍
- NoSQL 數據庫（MongoDB）
  - 優點：靈活的數據模型
  - 缺點：需要額外服務、增加複雜度
  - 理由：不符合最小實現原則

---

## 會話處理選項探索

### 方案 B1：無狀態令牌（JWT）✅ 已選擇

**特點：**
- 使用 JWT（JSON Web Token）
- 令牌包含所有必要信息
- 無需服務器端會話存儲

**優點：**
- ✅ 無狀態設計，易於擴展
- ✅ 適合分散式系統和多實例部署
- ✅ 令牌可以在客戶端存儲（localStorage、cookie）
- ✅ 標準化的認證機制
- ✅ 不依賴服務器內存

**缺點：**
- 令牌一旦簽發，在過期前無法撤銷（但可通過短過期時間緩解）
- 令牌大小較大（但通常可接受）

**選擇理由：**
JWT 提供了無狀態認證機制，適合未來可能的多實例部署。雖然有無法撤銷的限制，但對於演示場景來說，24小時的過期時間是可接受的。

**實現細節：**
- 使用 `PyJWT` 庫
- HS256 算法（對稱加密）
- 令牌包含：username、iat、exp
- 過期時間：24 小時

### 方案 B2：內存會話映射（In-memory Session Map）

**特點：**
- 服務器端維護 session_id 到用戶名的映射
- 客戶端存儲 session_id（cookie 或 token）
- 需要服務器端狀態

**優點：**
- 實現簡單
- 可以輕易撤銷會話
- 不依賴外部庫

**缺點：**
- ❌ 需要服務器端內存存儲
- ❌ 不適合多實例部署（狀態不共享）
- ❌ 服務器重啟導致所有用戶登出
- ❌ 無法水平擴展

**未選擇理由：**
雖然實現簡單，但方案 B2 無法適應多實例部署，限制了系統的擴展性。對於演示場景，方案 B1 更為合適。

**未探索的替代方案：**
- 分布式會話存儲（Redis）
  - 優點：支持多實例、可以撤銷會話
  - 缺點：需要額外的 Redis 服務
  - 理由：增加系統複雜度，超出最小實現範圍
- 數據庫會話存儲
  - 優點：持久化、支持多實例
  - 缺點：每次請求需要查詢數據庫
  - 理由：性能開銷較大，不符合無狀態設計原則

---

## 待辦事項存儲選項探索

### 方案 C1：內存列表（In-memory Lists）

**特點：**
- 使用 Python 字典或列表存儲待辦事項
- 按用戶 ID 組織
- 數據僅存在於內存中

**優點：**
- 實現最簡單
- 讀寫速度快（無 I/O）
- 適合快速原型

**缺點：**
- ❌ 無持久化能力
- ❌ 服務器重啟後所有數據丟失
- ❌ 不適合任何需要數據保留的場景

**使用場景：**
- 僅用於臨時測試
- 不需要持久化的演示

### 方案 C2：JSON 檔案持久化 ✅ 已選擇

**特點：**
- 使用 JSON 文件存儲所有待辦事項
- 每次操作讀寫文件
- 提供持久化能力

**優點：**
- ✅ 數據持久化，服務器重啟不丟失
- ✅ JSON 格式易於閱讀和調試
- ✅ 與用戶存儲方案一致（同樣使用文件）
- ✅ 可以輕易遷移到數據庫（讀寫接口相同）
- ✅ 無需額外數據庫依賴

**缺點：**
- 併發寫入可能導致數據不一致（演示場景可接受）
- 性能不如數據庫（但對演示場景足夠）
- 大數據量時性能下降

**選擇理由：**
與用戶存儲選擇一致，使用 JSON 文件提供簡單且有效的持久化方案。保持了實現的一致性，同時提供了必要的數據保留能力。

**ID 生成策略：**
- 選擇：UUID v4（`uuid.uuid4()`）
- 理由：
  - 全局唯一性
  - 無需服務器協調
  - 分散式友好
- 替代方案（未採用）：
  - 自增 ID：需要全局計數器，不適合分散式
  - 時間戳：可能有衝突風險

**未探索的替代方案：**
- 關係型數據庫
  - 優點：事務支持、查詢能力、數據完整性
  - 缺點：增加複雜度、需要數據庫依賴
  - 理由：超出最小實現範圍，可以未來遷移
- 嵌入式數據庫（SQLite）
  - 優點：文件基礎、無需服務、SQL 支持
  - 缺點：併發寫入限制
  - 理由：JSON 文件更簡單，對演示場景足夠

---

## 其他設計決策

### HTTP 框架選擇

**選擇：Flask**

**理由：**
- 輕量級，適合最小實現
- 易於理解和使用
- 豐富的社區支持
- 符合 Python 基礎實現的要求

**替代方案（未採用）：**
- FastAPI：現代、快速，但對最小實現來說過於複雜
- Django：功能完整，但對於簡單 API 來說過重
- Tornado：異步支持，但不符合最小實現原則

### 密碼哈希算法

**選擇：bcrypt**

**理由：**
- 專為密碼哈希設計
- 內置鹽值生成
- 計算成本可調（對抗暴力破解）
- Python 標準庫生態系統支持良好

**替代方案（未採用）：**
- scrypt：同樣優秀，但 bcrypt 更常用
- PBKDF2：較舊，bcrypt 更推薦
- Argon2：最新推薦，但 bcrypt 對演示場景足夠

### 錯誤處理策略

**策略：返回 JSON 錯誤響應**

**實現：**
- 所有錯誤以 JSON 格式返回
- 包含適當的 HTTP 狀態碼
- 錯誤消息清晰明確

**取捨：**
- 簡單但有效的錯誤處理
- 不包含詳細的錯誤堆棧（生產環境可添加）
- 不包含錯誤 ID（可作為未來改進）

---

## 探索總結

### 選擇的組合

- **認證存儲**：檔案基礎用戶存儲（方案 A2）
- **會話處理**：JWT 無狀態令牌（方案 B1）
- **待辦事項存儲**：JSON 檔案持久化（方案 C2）

### 設計原則

1. **最小實現**：選擇最簡單但足夠的方案
2. **持久化優先**：選擇提供數據保留能力的方案
3. **一致性**：待辦事項存儲與用戶存儲使用相同的文件方案
4. **可擴展性**：選擇支持未來擴展的方案（如 JWT 支持分散式）
5. **清晰分離**：明確分離認證和待辦事項領域

### 未來可能的演化方向

1. **數據庫遷移**：將文件存儲遷移到數據庫（SQLite 或 PostgreSQL）
2. **令牌撤銷**：如果未來需要，可以實現令牌黑名單機制
3. **併發控制**：如果需要，可以添加文件鎖定或遷移到數據庫
4. **緩存層**：如果需要提升性能，可以添加 Redis 緩存
5. **API 文檔**：可以添加 OpenAPI/Swagger 文檔

### 未選擇方案的保留價值

雖然未選擇某些方案（如內存存儲），但這些方案對於：
- 單元測試（可以使用內存存儲進行快速測試）
- 性能基準測試（可以比較文件 vs 內存性能）
- 未來決策（保留作為替代方案參考）

仍然具有價值。
